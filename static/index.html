
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Transient JS Request Console</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0 10px 40px 10px;
      background: #f0f0f0;
    }
    h1 {
      font-size: 1.4rem;
      margin-top: 10px;
    }
    #root {
      margin-top: 10px;
    }
    details {
      background: #fff;
    }
    .wallet-card {
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 6px;
      margin: 4px 0;
      display: flex;
      align-items: center;
      cursor: pointer;
      background: #fafafa;
    }
    .wallet-card img {
      width: 32px;
      height: 32px;
      margin-right: 8px;
    }
    .wallet-card:hover {
      background: #f0f0ff;
    }
  </style>
</head>
<body>
  <h1>Transient JS Request Console</h1>
  <div id="root"></div>

  <script src="handlers.js"></script>
  <script>
    // ============================================================
    // Función genérica: rellena un template de body con varValues
    // ============================================================
    function fillBodyWithValues(template, varValues) {
      // Primitivos
      if (
        template === null ||
        typeof template === "number" ||
        typeof template === "string" ||
        typeof template === "boolean"
      ) {
        // Si existe varValues.body, se usa. Si no, se deja el default.
        if (Object.prototype.hasOwnProperty.call(varValues, "body")) {
          return varValues.body;
        }
        return template;
      }

      // Arrays
      if (Array.isArray(template)) {
        return template.map(elem => fillBodyWithValues(elem, varValues));
      }

      // Objetos
      if (typeof template === "object") {
        const result = { ...template };
        Object.keys(result).forEach(key => {
          const val = result[key];

          if (Object.prototype.hasOwnProperty.call(varValues, key)) {
            result[key] = varValues[key];
          } else {
            result[key] = fillBodyWithValues(val, varValues);
          }
        });
        return result;
      }

      return template;
    }

    // ============================================================
    // Render principal
    // ============================================================

const renderItem = (item, container) => {
  console.log("renderItem item =", item, "isArray?", Array.isArray(item));

  const details = document.createElement("details");
  details.style.cssText =
    "margin:10px 0;border:1px solid #ccc;border-radius:4px;padding:4px;";

  const summary = document.createElement("summary");
  summary.textContent =
    typeof item === "string"
      ? item
      : (item && typeof item === "object" && typeof item.msg === "string"
          ? item.msg
          : "See detail");
  summary.style.cssText = "cursor:pointer;font-weight:bold;";
  details.appendChild(summary);

  const div = document.createElement("div");
  div.style.cssText =
    "margin-top:6px;padding:6px;background:#f9f9f9;white-space:pre-wrap;font-family:monospace;";
  div.textContent =
    typeof item === "object"
      ? JSON.stringify(item, null, 2)
      : String(item);

  // ==========================================================
  // Si item.req existe -> construimos el formulario
  // ==========================================================
  if (item && typeof item === "object" && item.req) {
    const req = item.req;

    const form = document.createElement("div");
    form.style.marginTop = "8px";

    // vínculo item <-> form
    form._item = item;
    item._form = form;
    item._req = req;

    // --------------------------------------------------------
    // Detección de variables en URL y body (item._vars)
    // --------------------------------------------------------
    const vars = {};

if (req.requrl) {
  const reUrl = /\$(\w+)/g;
  let m;
  while ((m = reUrl.exec(req.requrl)) !== null) {
    vars[m[1]] = true;
  }
}
// Solo escanear el body si NO es GET
const method = req.reqtype || "GET";
if (method !== "GET" && req.reqbody && typeof req.reqbody === "string") {
  const reBody = /\$(\w+)/g;
  let m;
  while ((m = reBody.exec(req.reqbody)) !== null) {
    vars[m[1]] = true;
  }
}


    item._vars = vars;

    // Optional JSON HEADERS
    let headersTa = null;
    if (req.reqheaders) {
      headersTa = document.createElement("textarea");
      headersTa.placeholder = "reqheaders (JSON)";
      headersTa.value = req.reqheaders;
      headersTa.id = `headers_${Math.random().toString(16).slice(2)}`;
      headersTa.style.display = "block";
      headersTa.style.marginTop = "4px";
      form.appendChild(headersTa);
    }



    // Botón Send
    const btn = document.createElement("button");
    btn.textContent = "Process";
    btn.style.cssText = "margin-top:6px;padding:4px 8px;";



async function handleResponse(res) {
  if (!res.body) {
    const text = await res.text();
    console.log("TEXT RECEIVED (no stream)", text);

    let result;
    try {
      result = JSON.parse(text);
    } catch {
      result = text;
    }

    if (Array.isArray(result)) {
      result.forEach(it => renderItem(it, div));
    } else {
      renderItem(result, div);
    }
    return;
  }

  const reader = res.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  let inArray = false;
  let depth = 0;
  let current = "";

  const flushElement = chunk => {
    const s = chunk.trim();
    if (!s) return;

    let parts = [];
    let d = 0;
    let currentPart = "";

    for (let i = 0; i < s.length; i++) {
      const ch = s[i];

      if (ch === "{" || ch === "[") d++;
      if (ch === "}" || ch === "]") d--;

      if (ch === "," && d === 0) {
        if (currentPart.trim()) parts.push(currentPart.trim());
        currentPart = "";
      } else {
        currentPart += ch;
      }
    }
    if (currentPart.trim()) parts.push(currentPart.trim());

    parts.forEach(part => {
      const clean = part.trim();
      if (!clean) return;
      console.log("JSON ELEMENT PART", clean);
      try {
        const parsed = JSON.parse(clean);
        if (Array.isArray(parsed)) {
          parsed.forEach(it => renderItem(it, div));
        } else {
          renderItem(parsed, div);
        }
      } catch (e) {
        console.error("Error parsing element", e, clean);
      }
    });
  };

  while (true) {
    const { value, done } = await reader.read();
    if (done) break;

    const chunkText = decoder.decode(value, { stream: true });
    console.log("CHUNK RAW", chunkText);
    buffer += chunkText;

    for (let i = 0; i < buffer.length; i++) {
      const ch = buffer[i];

      if (!inArray) {
        if (ch === "[") {
          inArray = true;
        }
        continue;
      }

      if (ch === "]" && depth === 0) {
        flushElement(current);
        current = "";
        inArray = false;
        continue;
      }

      current += ch;

      if (ch === "{" || ch === "[") depth++;
      if (ch === "}" || ch === "]") depth--;

      if (
        inArray &&
        depth === 0 &&
        (ch === "}" || ch === "]")
      ) {
        flushElement(current);
        current = "";
      }
    }

    buffer = "";
  }

  flushElement(current);
}




  btn.onclick = async (ev) => {
    ev.preventDefault();

    const req = item._req;
    const baseVars = item._vars || {};
    const method = req.reqtype || "GET";

    const path = new URL(req.requrl, window.location.origin).pathname;
    const special = window.specialVarHandlers?.[path];

    // ¿hay variables provenientes de $foo en url/body?
    const hasVars = Object.keys(baseVars).length > 0;

    // body primitivo (lo que ya tenías soportado)
    const isPrimitiveBody =
      method !== "GET" &&
      req.reqbody !== null &&
      req.reqbody !== undefined &&
      (typeof req.reqbody === "number" ||
        typeof req.reqbody === "string" ||
        typeof req.reqbody === "boolean");

    // NUEVO: body objeto plano de primer nivel
    const isPlainObjectBody =
      method !== "GET" &&
      req.reqbody &&
      typeof req.reqbody === "object" &&
      !Array.isArray(req.reqbody);

    console.log("DEBUG hasVars =", hasVars);
    console.log("DEBUG isPrimitiveBody =", isPrimitiveBody);
    console.log("DEBUG isPlainObjectBody =", isPlainObjectBody);
    console.log("DEBUG special =", special);

    // ===== CASO 1: GET sin vars ni body editable -> FETCH DIRECTO =====
    if (!special && method === "GET" && !hasVars && !isPrimitiveBody && !isPlainObjectBody) {
      const body = req.reqbody; // normalmente undefined o literal fijo

      const fetchOpts = {
        method,
        headers: { "Content-Type": "application/json" },
      };

      try {
        const res = await fetch(req.requrl, fetchOpts);
        await handleResponse(res);
      } catch (e) {
        console.error(e);
        div.textContent += `\nError: ${e.message}`;
      }

      return; // IMPORTANTE: salir aquí
    }

    // ===== CASO 2: HAY SPECIAL O EDICIÓN DE USUARIO =====
    let specialVars;

    if (special) {
      console.log("RAMA: special");
      specialVars = await special(baseVars, item);
    } else if (isPlainObjectBody && !hasVars) {
      console.log("RAMA: objectBodyInputHandler");
      specialVars = await objectBodyInputHandler(baseVars, item);
    } else {
      console.log("RAMA: userInputHandler");
      specialVars = await userInputHandler(baseVars, item);
    }

    const vars = { ...baseVars };
    if (Array.isArray(specialVars)) {
      specialVars.forEach(v => {
        if (!v || typeof v.name !== "string") return;
        vars[v.name] = v.value;
      });
    }

    // >>> AQUÍ VA LA RAMA ESPECIAL PARA GET CON $vars <<<
    if (method === "GET") {
      alert(["vars",JSON.stringify(vars)]);
      const finalUrl = fillBodyWithValues(req.requrl, vars);
      console.log("DEBUG finalUrl =", finalUrl);

      const fetchOpts = {
        method,
        headers: { "Content-Type": "application/json" },
      };

      try {
        const res = await fetch(finalUrl, fetchOpts);
        await handleResponse(res);
      } catch (e) {
        console.error(e);
        div.textContent += `\nError: ${e.message}`;
      }
      return;
    }

    // Construir body con o sin plantilla
    let body;
    const reqBody = req.reqbody;
    const hasTemplateVars =
      typeof reqBody === "string" && /\$\w+/.test(reqBody);

    if (!hasTemplateVars && "body" in vars) {
      // body viene de userInputHandler u objectBodyInputHandler
      body = vars.body;
    } else {
      // comportamiento antiguo: plantilla sobre reqbody string
      body = fillBodyWithValues(reqBody, vars);
    }

    const fetchOpts = {
      method,
      headers: { "Content-Type": "application/json" },
    };

    if (method === "POST" || method === "PUT" || method === "PATCH") {
      if (body !== undefined) {
        fetchOpts.body = JSON.stringify(body);
      }
    }

    try {
      const res = await fetch(req.requrl, fetchOpts);
      await handleResponse(res); // SOLO lectura y render de respuesta
    } catch (e) {
      console.error(e);
      div.textContent += `\nError: ${e.message}`;
    }
  };




    // btn.textContent = "Enviar";
    form.appendChild(btn);
    div.appendChild(form);
  }

  details.appendChild(div);
  container.appendChild(details);
};


    // ============================================================
    // Bootstrap: usa window.initialRequestMessage
    // ============================================================
    (function init() {
      const root = document.getElementById("root");
      if (!root) return;

      if (window.initialRequestMessage) {
        renderItem(window.initialRequestMessage, root);
      } else {
        root.textContent = "No initialRequestMessage defined.";
      }
    })();
  </script>
</body>
</html>
